package dfki.rdf.util;

import java.util.*;
import org.w3c.rdf.model.*;
import java.lang.reflect.*;


/** Root object of all Java-Objects generated by the {@link RDFS2Class RDFS2Class} tool.
  * <p>
  * Every generated Java object corresponds to a specific RDFS class.
  * If such an RDFS class doesn't have a super class, i.e. has a <code>rdfs:subClassOf</code> link
  * to another RDFS class, then the generated Java class for this RDFS class <code>extends</code>
  * this <code>THING</code> class.
  * <p>
  * This class does already contain some usefull slots and methods, such as for example
  * the getter and putter method of the <code>URI</code> of the corresponding RDF object.
  * <p>
  * @author  Sven.Schwarz@dfki.de
  * @version 1.0
  */
public class THING   extends RDFResource
{
//----------------------------------------------------------------------------------------------------
final static protected String DEFAULT_NAMESPACE = "http://dfki.rdf.util.rdf2java/default#";

//----------------------------------------------------------------------------------------------------
/** <code>toString()<code> stuff...
  */
public String toString ()
{
    return toString("");
}

//----------------------------------------------------------------------------------------------------
/** <code>toString()<code> stuff...
  */
public String toString (String sIndent)
{
    return toString_userDefined(sIndent, true);
}

//----------------------------------------------------------------------------------------------------
/** <code>toString()<code> stuff...
  */
public String toString (String sIndent, boolean bIndentDirectly)
{
    StringBuffer sb = new StringBuffer();
    if (bIndentDirectly)
        sb.append(sIndent);
    sb.append(getClassName() + " " + getAddress() + " ");
    if (getURI() != null)
        sb.append("URI=\"" + getURI() + "\" ");
//    sb.append("{");
    sb.append("\n");
    toString(sb, sIndent);
//    sb.append(sIndent + "}\n");
    return sb.toString();
}

//----------------------------------------------------------------------------------------------------
/** <code>toString()<code> stuff: <b>this method is overloaded for subclasses of <code>THING</code>!</b>
  */
public void toString (StringBuffer sb, String sIndent)  // overload this method
{
}

//----------------------------------------------------------------------------------------------------
public String toString_userDefined (String sIndent, boolean bIndentDirectly)
{
    return toString(sIndent, bIndentDirectly);
}

//----------------------------------------------------------------------------------------------------
/** <code>toString()<code> stuff: <b>this method can be overloaded for subclasses of <code>THING</code>!</b>
  */
public String toStringShort ()                          // overload this method
{
    return getClassNameShort() + " " +
           getAddress() +
           ( getURI() != null  ?  " URI=\"" + getURI() + "\""  :  "");
}

//----------------------------------------------------------------------------------------------------
/** Creates a new URI (with default namespace) and {@link #putURI stores} this URI in this object.
  */
public String makeNewURI ()
{
    return makeNewURI(DEFAULT_NAMESPACE);
}

//----------------------------------------------------------------------------------------------------
/** Creates a new URI (with given namespace) and {@link #putURI stores} this URI in this object.
  */
public String makeNewURI (String sNamespace)
{
    Date date = new Date();
    String sNewURI = sNamespace + "id_" + date.getTime() + "_" + getAddressOnlyHex();
    putURI(sNewURI);
    return sNewURI;
}

//----------------------------------------------------------------------------------------------------
/** Creates a new URI for this object, stores it in the object and in the given map.
  */
public void addToMap (Map mapObjects, String sNamespace)
{
    try {
        if (getURI() == null)
            makeNewURI(sNamespace);
        mapObjects.put(getURI(), this);
    }
    catch (Exception ex)
    {
        System.out.println("Exception (" + ex.getClass() + ") occurred: "+ex.getMessage());
        ex.printStackTrace();
        throw new Error(ex.getMessage());
    }
}

//----------------------------------------------------------------------------------------------------
/** Creates a new URI for this object, stores it in the object and in the given map.
  */
public void addToMap (Map mapObjects)
{
    addToMap(mapObjects, DEFAULT_NAMESPACE);
}

//----------------------------------------------------------------------------------------------------
public Object getPropertyValue (String sPropertyName)
{
    return RDF2Java.getPropertyValue( this, sPropertyName );
}

//----------------------------------------------------------------------------------------------------
public void updateRDFResourceSlots (KnowledgeBase kbCachedObjects)
{
    try
    {
        Class cls = getClass();
        Collection collProperties = getProperties();
        for (Iterator itProperties = collProperties.iterator(); itProperties.hasNext(); )
        {
            String sPropertyName = (String)itProperties.next();
            String sGetMethodName = RDF2Java.makeMethodName("get", sPropertyName);
            String sPutMethodName = RDF2Java.makeMethodName("put", sPropertyName);
            Method methodGet = RDF2Java.getMethod( cls, sGetMethodName, new Class[0] );
            if (methodGet == null) throw new Exception("missing method " + sGetMethodName + "()");
            Object objPropValue = methodGet.invoke(this, null);
            if (objPropValue == null)
                continue;
            if (objPropValue instanceof Collection)
            {
                Collection listOldValues = new LinkedList( (Collection)objPropValue );
                String sClearMethodName = RDF2Java.makeMethodName("clear", sPropertyName);
                Method methodClear = RDF2Java.getMethod( cls, sClearMethodName, new Class[0] );
                if (methodClear == null) throw new Exception("missing method " + sClearMethodName + "()");
                methodClear.invoke( this, null );
                for (Iterator itPropValues = listOldValues.iterator(); itPropValues.hasNext(); )
                {
                    Object objPropValueElement = itPropValues.next();
                    if (objPropValueElement instanceof RDFResource)
                    {
                        RDFResource res = (RDFResource)objPropValueElement;
                        Object cachedObject = kbCachedObjects.get(res.getURI());
                        if (cachedObject != null && (cachedObject instanceof THING))
                        {
                            Method methodPut = RDF2Java.getMethod( cls, sPutMethodName, new Class[] { cachedObject.getClass() } );
                            if (methodPut == null) throw new Exception("missing method " + sPutMethodName + "(" + cachedObject.getClass() + ")");
                            methodPut.invoke( this, new Object[] { cachedObject } );
                            continue;
                        }
                    }
                    // nothing better available => take the old slot value again
                    Method methodPut = RDF2Java.getMethod( cls, sPutMethodName, new Class[] { objPropValueElement.getClass() } );
                    if (methodPut == null) throw new Exception("missing method " + sPutMethodName + "(" + objPropValueElement.getClass() + ")");
                    methodPut.invoke( this, new Object[] { objPropValueElement } );
                }
            }
            else
            if (objPropValue instanceof RDFResource)
            {
                if (objPropValue instanceof THING)
                    continue;
                try {
                    RDFResource propValue = (RDFResource)objPropValue;
                    Object cachedObject = kbCachedObjects.get(propValue.getURI());
                    if (cachedObject != null && (cachedObject instanceof THING))
                    {
                        Method methodPut = RDF2Java.getMethod( cls, sPutMethodName, new Class[] { cachedObject.getClass() } );
                        if (methodPut == null) throw new Exception("missing method " + sPutMethodName + "(" + cachedObject.getClass() + ")");
                        methodPut.invoke( this, new Object[] { cachedObject } );
                        continue;
                    }
                    // nothing better available => take the old slot value again
                    Method methodPut = RDF2Java.getMethod( cls, sPutMethodName, new Class[] { RDFResource.class } );
                    if (methodPut == null) throw new Exception("missing method " + sPutMethodName + "(" + RDFResource.class + ")");
                    methodPut.invoke( this, new Object[] { propValue } );
                }
                catch (Exception ex) {
                    System.out.println("Exception (" + ex.getClass() + ") occurred: "+ex.getMessage());
                    ex.printStackTrace();
                    throw new Error(ex.getMessage());
                }
            }
            else
            if ( !(objPropValue instanceof String) )
                throw new Error("Wrong class for objValue in dfki.rdf.util.THING . updateRDFResourceSlots; class=" + objPropValue.getClass());
        }
    }
    catch (Exception ex)
    {
        System.out.println("dfki.rdf.util.THING . updateRDFResourceSlots: Exception (" + ex.getClass() + ") occurred" + ex);
        ex.printStackTrace();
        throw new Error(ex.getMessage());
    }
}

//----------------------------------------------------------------------------------------------------
public void assign (THING newThing, KnowledgeBase kb)
{
    try
    {
        Class cls = getClass();
        Collection collProperties = getProperties();
        for (Iterator itProperties = collProperties.iterator(); itProperties.hasNext(); )
        {
            String sPropertyName = (String)itProperties.next();
            String sGetMethodName = RDF2Java.makeMethodName("get", sPropertyName);
            String sPutMethodName = RDF2Java.makeMethodName("put", sPropertyName);
            Method methodGet = RDF2Java.getMethod( cls, sGetMethodName, new Class[0] );
            if (methodGet == null) throw new Exception("missing method " + sGetMethodName + "()");
            Object objPropValue = methodGet.invoke(this, null);
            if (objPropValue == null)
                continue;
            if (objPropValue instanceof Collection)
            {
                LinkedList lstOldValues = new LinkedList( (Collection)objPropValue );

                Object objPropNewValue = methodGet.invoke( newThing, null );
                LinkedList lstNewValues = new LinkedList( (Collection)objPropNewValue );

                String sClearMethodName = RDF2Java.makeMethodName("clear", sPropertyName);
                Method methodClear = RDF2Java.getMethod( cls, sClearMethodName, new Class[0] );
                if (methodClear == null) throw new Exception("missing method " + sClearMethodName + "()");
                methodClear.invoke( this, null );

                assignValues(lstOldValues, lstNewValues, sPutMethodName, kb);
            }
            else
            {
                LinkedList lstOldValues = new LinkedList();
                if (objPropValue != null) lstOldValues.add( objPropValue );

                LinkedList lstNewValues = new LinkedList();
                Object objPropNewValue = methodGet.invoke( newThing, null );
                if (objPropNewValue != null) lstNewValues.add( objPropNewValue );

                Method methodPut = RDF2Java.getMethod( cls, sPutMethodName, new Class[] { objPropValue.getClass() } );
                if (methodPut == null) throw new Exception("missing method " + sPutMethodName + "(" + objPropValue.getClass() + ")");
                methodPut.invoke( this, new Object[] { null } );

                assignValues(lstOldValues, lstNewValues, sPutMethodName, kb);
            }
        }
    }
    catch (Exception ex)
    {
        System.out.println("Exception (" + ex.getClass() + ") occurred: "+ex.getMessage());
        ex.printStackTrace();
        throw new Error(ex.getMessage());
    }
}

//----------------------------------------------------------------------------------------------------
void assignValues (Collection collOldValues, Collection collNewValues,
                   String sPutMethodName, KnowledgeBase kb)   throws Exception
{
    for (Iterator itOldValues = collOldValues.iterator(); itOldValues.hasNext(); )
    {
        Object oldValue = itOldValues.next();
        if ( !(oldValue instanceof RDFResource) )
            continue;  // slot value is a LITERAL => handle that case below => assign NEW slot value (overwrite old value)
        Object newValue = find(collNewValues, ((RDFResource)oldValue).getURI());

        // if newValue == null, then the old slot value (subA_this) has to be removed
        // as this is already done (in the calling assign method), nothing has to be done in that case
        if (newValue == null)
            continue;

        // if the new slot value gives us an increase of quality, we take it!
        // this can only be the case iff newValue is a THING (and not an URI reference)
        // as this case is handled deeper below, too, we only do the other case here:
        // A L T H O U G H :   note, that this disturbs the order of the slot values !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        if ( newValue instanceof THING )
            continue;  // newValue is not remove from collNewValues and will therfore be handled again below

        Method methodPut = RDF2Java.getMethod( getClass(), sPutMethodName, new Class[] { oldValue.getClass() } );
        if (methodPut == null) throw new Exception("missing method " + sPutMethodName + "(" + oldValue.getClass() + ")");
        methodPut.invoke( this, new Object[] { oldValue } );  // insert the newer slot value
        // mark, that we've already handled that new slot value (inspected below)
        remove(collNewValues, ((RDFResource)newValue).getURI());
    }

    // if collNewValues still contains some slot values => add them all
    for (Iterator itNewValues = collNewValues.iterator(); itNewValues.hasNext(); )
    {
        Object newValue = itNewValues.next();
        Method methodPut = RDF2Java.getMethod( getClass(), sPutMethodName, new Class[] { newValue.getClass() } );
        if (methodPut == null) throw new Exception("missing method " + sPutMethodName + "(" + newValue.getClass() + ")");
        methodPut.invoke( this, new Object[] { newValue } );  // insert the newer slot value

        if (newValue instanceof THING)
            kb.put( newValue );     // now the new Java object exists in the knowledge base, too
    }
}

//----------------------------------------------------------------------------------------------------
public static Object find (Collection collOther, String sURI)
{
    for (Iterator itOthers = collOther.iterator(); itOthers.hasNext(); )
    {
        Object other = itOthers.next();
        if ( (other instanceof RDFResource) &&
             ((RDFResource)other).getURI().equals(sURI) )
            return other;
    }
    return null;  // not found
}

//----------------------------------------------------------------------------------------------------
public static void remove (Collection coll, String sURI)
{
    for (Iterator it = coll.iterator(); it.hasNext(); )
    {
        Object obj = it.next();
        if ( (obj instanceof RDFResource) &&
             ((RDFResource)obj).getURI().equals(sURI) )
        {
            it.remove();
            return;
        }
    }
}

//----------------------------------------------------------------------------------------------------
}

