package dfki.rdf.util;

import java.util.*;
import org.w3c.rdf.model.*;
import java.lang.reflect.*;


/** Root object of all Java-Objects generated by the {@link RDFS2Class RDFS2Class} tool.
  * <p>
  * Every generated Java object corresponds to a specific RDFS class.
  * If such an RDFS class doesn't have a super class, i.e. has a <code>rdfs:subClassOf</code> link
  * to another RDFS class, then the generated Java class for this RDFS class <code>extends</code>
  * this <code>THING</code> class.
  * <p>
  * This class does already contain some usefull slots and methods, such as for example
  * the getter and putter method of the <code>URI</code> of the corresponding RDF object.
  * <p>
  * @author  Sven.Schwarz@dfki.de
  * @version 1.0
  */
public class THING   extends RDFResource
{
//----------------------------------------------------------------------------------------------------
/** <code>toString()<code> stuff...
  */
public String toString ()
{
    return toString("");
}

//----------------------------------------------------------------------------------------------------
/** <code>toString()<code> stuff...
  */
public String toString (String sIndent)
{
    return toString_userDefined(sIndent, true);
}

//----------------------------------------------------------------------------------------------------
/** <code>toString()<code> stuff...
  */
public String toString (String sIndent, boolean bIndentDirectly)
{
    StringBuffer sb = new StringBuffer();
    if (bIndentDirectly)
        sb.append(sIndent);
    sb.append(getClassName() + " " + getAddress() + " ");
    if (getURI() != null)
        sb.append("URI=\"" + getURI() + "\" ");
//    sb.append("{");
    sb.append("\n");
    toString(sb, sIndent);
//    sb.append(sIndent + "}\n");
    return sb.toString();
}

//----------------------------------------------------------------------------------------------------
/** <code>toString()<code> stuff: <b>this method is overloaded for subclasses of <code>THING</code>!</b>
  */
public void toString (StringBuffer sb, String sIndent)  // overload this method
{
}

//----------------------------------------------------------------------------------------------------
public String toString_userDefined (String sIndent, boolean bIndentDirectly)
{
    return toString(sIndent, bIndentDirectly);
}

//----------------------------------------------------------------------------------------------------
/** <code>toString()<code> stuff: <b>this method can be overloaded for subclasses of <code>THING</code>!</b>
  */
public String toStringShort ()                          // overload this method
{
    return getClassNameShort() + " " +
           getAddress() +
           ( getURI() != null  ?  " URI=\"" + getURI() + "\""  :  "");
}

//----------------------------------------------------------------------------------------------------
/** Gets the class name of this object.
  */
protected String getClassName ()
{
    return getClassNameShort() + " (" + getClass().getName() + ")";
}

//----------------------------------------------------------------------------------------------------
/** Gets a short version (without package) of the class name of this object.
  */
protected String getClassNameShort ()
{
    String sClassName = getClass().getName();
    int pos = sClassName.lastIndexOf('.');
    if (pos >= 0)
        return sClassName.substring(pos+1);
    else
        return sClassName;
}

//----------------------------------------------------------------------------------------------------
/** Gets a string showing the address of this object in hex notation.
  * <br>
  * The string is prefixed with a <code>'@'</code> character.
  */
protected String getAddress ()
{
    return "@" + Integer.toHexString(this.hashCode());
}

//----------------------------------------------------------------------------------------------------
/** Gets a string showing the address of this object in hex notation.
  * <br>
  * The string is <b>not</b> prefixed with a <code>'@'</code> character.
  */
protected String getAddressOnlyHex ()
{
    return Integer.toHexString(this.hashCode());
}

//----------------------------------------------------------------------------------------------------
/** Creates a new URI (with default namespace) and {@link #putURI stores} this URI in this object.
  */
public String makeNewURI ()
{
    return makeNewURI("http://dfki.frodo/default#");
}

//----------------------------------------------------------------------------------------------------
/** Creates a new URI (with given namespace) and {@link #putURI stores} this URI in this object.
  */
public String makeNewURI (String sNamespace)
{
    Date date = new Date();
    String sNewURI = sNamespace + "id_" + date.getTime() + "_" + getAddressOnlyHex();
    putURI(sNewURI);
    return sNewURI;
}

//----------------------------------------------------------------------------------------------------
/** Creates a new URI for this object, stores it in the object and in the given map.
  */
public void addToMap (Map mapObjects, String sNamespace)
{
    try {
        makeNewURI(sNamespace);
        Resource resNewURI = dfki.util.rdf.RDF.factory().getNodeFactory().createResource(getURI());
        mapObjects.put(resNewURI, this);
    }
    catch (Exception ex)
    {
        System.out.println("Exception occurred: "+ex.getMessage());
        ex.printStackTrace();
        throw new Error(ex.getMessage());
    }
}

//----------------------------------------------------------------------------------------------------
/** Creates a new URI for this object, stores it in the object and in the given map.
  */
public void addToMap (Map mapObjects)
{
    addToMap(mapObjects, "http://dfki.rdf.util.rdf2java/default#");
}

//----------------------------------------------------------------------------------------------------
public void updateRDFResourceSlots (KnowledgeBase kbCachedObjects)
{
    Class cls = getClass();
    Method[] aMethods = cls.getMethods();
    for (int i = 0; i < aMethods.length; i++)
    {
        Method method = aMethods[i];
        String sMethodName = method.getName();
        if (!sMethodName.startsWith("Get") || !sMethodName.endsWith("__asURI"))
            continue;
        Class[] aParameterTypes = method.getParameterTypes();
        if (aParameterTypes.length > 0)
            continue;
        Object objPropValue = null;
        try {
            objPropValue = method.invoke(this, null);
        } catch (Exception ex) {
            System.out.println("dfki.rdf.util.THING . updateRDFResourceSlots: Exception occurred" + ex);
        }
        if (objPropValue == null)
            continue;
        String sPropertyName = calcMethodNameToPropertyName(sMethodName);
        String sPutMethodName = calcPropertyNameToMethodNameWithoutURI("put", sPropertyName);
        if ( !(objPropValue instanceof THING) )
        {
            try {
                RDFResource propValue = (RDFResource)objPropValue;
                Object cachedObject = kbCachedObjects.get(propValue.getURI());
                if (cachedObject == null || !(cachedObject instanceof THING)) continue;
                Method methodPutterNormal = myGetMethod( cls, sPutMethodName, new Class[] { cachedObject.getClass() } );
                Method methodPutterURI = myGetMethod( cls, sPutMethodName, new Class[] { RDFResource.class } );
                methodPutterURI.invoke( this, new Object[] { null } );
                methodPutterNormal.invoke( this, new Object[] { cachedObject } );
            }
            catch (Exception ex) {
                throw new Error(ex.getMessage());
            }
        }
        else
        if (objPropValue instanceof java.util.Collection)
        {
            try {
                for (Iterator itURIs = ((java.util.Collection)objPropValue).iterator(); itURIs.hasNext(); )
                {
                    RDFResource uri = (RDFResource)itURIs.next();
                    Object cachedObject = kbCachedObjects.get(uri);
                    if (cachedObject == null || !(cachedObject instanceof THING)) continue;
                    Method methodPutterNormal = myGetMethod( cls, sPutMethodName, new Class[] { cachedObject.getClass() } );
                    methodPutterNormal.invoke( this, new Object[] { cachedObject } );
                    itURIs.remove();
                }
            }
            catch (Exception ex) {
                throw new Error(ex.getMessage());
            }
        }
        else
            throw new Error("Wrong class for objValue in dfki.rdf.util.THING . updateRDFResourceSlots");
    }
}

String calcMethodNameToPropertyName (String sMethodName)
{
    // getXXYYZZ --> XXYYZZ
    if (sMethodName.startsWith("get_"))
        return sMethodName.substring(4);
    else
        return Character.toLowerCase(sMethodName.charAt(3)) + sMethodName.substring(4);
}

String calcPropertyNameToMethodNameWithoutURI (String sMethodPrefix, String sPropName)
{
    if (Character.isLowerCase(sPropName.charAt(0)))
        return sMethodPrefix + Character.toUpperCase(sPropName.charAt(0))
                             + sPropName.substring(1);
    else
        return sMethodPrefix + "_" + sPropName;
}


//----------------------------------------------------------------------------------------------------
public void assign (THING newThing, KnowledgeBase kb)
{
    try
    {
        Class cls = getClass();
        Method[] aMethods = cls.getMethods();
        for (int i = 0; i < aMethods.length; i++)
        {
            Method method = aMethods[i];
            String sMethodName = method.getName();
            if (!sMethodName.startsWith("get"))
                continue;
            if (method.getDeclaringClass().equals(RDFResource.class))
                continue;
            if (sMethodName.equals("getClass"))
                continue;
            Class[] aParameterTypes = method.getParameterTypes();
            if (aParameterTypes.length > 0)
                continue;

            String sPropertyName = calcMethodNameToPropertyName(sMethodName);
            String sPutMethodName = calcPropertyNameToMethodNameWithoutURI("put", sPropertyName);
            String sClearMethodName = calcPropertyNameToMethodNameWithoutURI("clear", sPropertyName);
            String sGetMethodName = calcPropertyNameToMethodNameWithoutURI("get", sPropertyName);
            String sGetAsURIMethodName = calcPropertyNameToMethodNameWithoutURI("Get", sPropertyName + "__asURI");

            Method methodPutAsURI = myGetMethod( cls, sPutMethodName, new Class[] { RDFResource.class } );
            Method methodClear = myGetMethod( cls, sClearMethodName, new Class[] { } );
            Method methodGet = myGetMethod( cls, sGetMethodName, new Class[] { } );
            Method methodGetAsURI = myGetMethod( cls, sGetAsURIMethodName, new Class[] { } );

            Class clsReturnType = methodGet.getReturnType();
            if (Collection.class.isAssignableFrom(clsReturnType))
            {
                Object value = methodGet.invoke( this, null );
                LinkedList lstOldValues = new LinkedList( (Collection)value );
                value = methodGetAsURI.invoke( this, null );
                lstOldValues.addAll( (Collection)value );

                methodClear.invoke( this, null );

                value = methodGet.invoke( newThing, null );
                LinkedList lstNewValues = new LinkedList( (Collection)value );
                value = methodGetAsURI.invoke( newThing, null );
                lstNewValues.addAll( (Collection)value );

                assignValues(lstOldValues, lstNewValues, sPutMethodName, kb);
            }
            else
            {
                LinkedList lstOldValues = new LinkedList();
                Object value = methodGet.invoke( this, null );
                if (value != null) lstOldValues.add( value );
                value = methodGetAsURI.invoke( this, null );
                if (value != null) lstOldValues.add( value );
                // assert( lstOldValues.size() > 1 )

                methodClear.invoke( this, null );

                LinkedList lstNewValues = new LinkedList();
                value = methodGet.invoke( newThing, null );
                if (value != null) lstNewValues.add( value );
                value = methodGetAsURI.invoke( newThing, null );
                if (value != null) lstNewValues.add( value );
                // assert( lstNewValues.size() > 1 )

                assignValues(lstOldValues, lstNewValues, sPutMethodName, kb);
            }
        }
    }
    catch (Exception ex)
    {
        throw new Error(ex.getMessage());
    }
}

//----------------------------------------------------------------------------------------------------
void assignValues (Collection collOldValues, Collection collNewValues,
                   String sPutMethodName, KnowledgeBase kb)   throws Exception
{
    for (Iterator itOldValues = collOldValues.iterator(); itOldValues.hasNext(); )
    {
        Object oldValue = itOldValues.next();
        if ( !(oldValue instanceof RDFResource) )
            continue;  // slot value is a LITERAL => handle that case below => assign NEW slot value (overwrite old value)
        Object newValue = find(collNewValues, ((RDFResource)oldValue).getURI());

        // if newValue == null, then the old slot value (subA_this) has to be removed
        // as this is already done (via method clearXXX), nothing has to be done in that case
        if (newValue == null)
            continue;

        // if the new slot value gives us an increase of quality, we take it!
        // this can only be the case iff newValue is a THING (and not an URI reference)
        // as this case is handled deeper below, too, we only do the other case here:
        // A L T H O U G H :   note, that this disturbs the order of the slot values !!!
        // OR WELL... DOES IT REALLY ???????????????????????????????????????????????????
        if ( newValue instanceof THING )
            continue;  // newValue is not remove from collNewValues and will therfore be handled again below

        Method methodPut = myGetMethod( getClass(), sPutMethodName, new Class[] { oldValue.getClass() } );
        methodPut.invoke( this, new Object[] { oldValue } );  // insert the newer slot value
        // mark, that we've already handled that new slot value (inspected below)
        remove(collNewValues, ((RDFResource)newValue).getURI());
    }

    // if collNewValues still contains some slot values => add them all
    for (Iterator itNewValues = collNewValues.iterator(); itNewValues.hasNext(); )
    {
        Object newValue = itNewValues.next();
        Method methodPut = myGetMethod( getClass(), sPutMethodName, new Class[] { newValue.getClass() } );
        methodPut.invoke( this, new Object[] { newValue } );  // insert the newer slot value

        if (newValue instanceof THING)
            kb.put( newValue );     // now the new Java object exists in the knowledge base, too
    }
}

//----------------------------------------------------------------------------------------------------
Method myGetMethod (Class cls, String sMethodName, Class[] aPars)
{
    Method[] aMethods = cls.getMethods();
    for (int i = 0; i < aMethods.length; i++)
    {
        Method m = aMethods[i];
        if (!m.getName().equals(sMethodName)) continue;
        if (!areAssignableFrom( m.getParameterTypes(), aPars )) continue;
        return m;
    }
    return null;  // not found
}

boolean areAssignableFrom (Class[] pars1, Class[] pars2)
{
    if (pars1.length != pars2.length) return false;
    for (int i = 0; i < pars1.length; i++)
    {
        if (!pars1[i].isAssignableFrom(pars2[i])) return false;
    }
    return true;  // pars1 ARE assignable from pars2
}

//----------------------------------------------------------------------------------------------------
public static Object find (Collection collOther, String sURI)
{
    for (Iterator itOthers = collOther.iterator(); itOthers.hasNext(); )
    {
        Object other = itOthers.next();
        if ( (other instanceof RDFResource) &&
             ((RDFResource)other).getURI().equals(sURI) )
            return other;
    }
    return null;  // not found
}

//----------------------------------------------------------------------------------------------------
public static void remove (Collection coll, String sURI)
{
    for (Iterator it = coll.iterator(); it.hasNext(); )
    {
        Object obj = it.next();
        if ( (obj instanceof RDFResource) &&
             ((RDFResource)obj).getURI().equals(sURI) )
        {
            it.remove();
            return;
        }
    }
}

//----------------------------------------------------------------------------------------------------
}

